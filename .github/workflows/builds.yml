name: builds

on:
  - push
  - pull_request

env:
  DEFAULT_LIBHTP_REPO: https://github.com/OISF/libhtp
  DEFAULT_LIBHTP_BRANCH: 0.5.x
  DEFAULT_LIBHTP_PR:

  DEFAULT_SU_REPO: https://github.com/OISF/suricata-update
  DEFAULT_SU_BRANCH: master
  DEFAULT_SU_PR:

  DEFAULT_SV_REPO: https://github.com/OISF/suricata-verify
  DEFAULT_SV_BRANCH: master
  DEFAULT_SV_PR:

  DEFAULT_CFLAGS: "-Wall -Wextra -Werror -Wno-unused-parameter -Wno-unused-function"

  # Apt sometimes likes to ask for user input, this will prevent that.
  DEBIAN_FRONTEND: "noninteractive"

  # A known good Rust version we should test against.
  RUST_VERSION_KNOWN: "1.37.0"

  # The minimum version of Rust supported.
  RUST_VERSION_MIN: "1.41.1"

jobs:

  prepare-deps:
    name: Prepare dependencies
    runs-on: ubuntu-latest
    steps:
      - name: Cache ~/.cargo
        uses: actions/cache@v1
        with:
          path: ~/.cargo
          key: cargo
      - run: sudo apt update && sudo apt -y install jq curl
      - name: Parse repo and branch information
        env:
          # We fetch the actual pull request to get the latest body as
          # github.event.pull_request.body has the body from the
          # initial pull request.
          PR_HREF: ${{ github.event.pull_request._links.self.href }}
        run: |
          if test "${PR_HREF}"; then
              body=$(curl -s "${PR_HREF}" | jq -r .body | tr -d '\r')

              libhtp_repo=$(echo "${body}" | awk '/^libhtp-repo/ { print $2 }')
              libhtp_branch=$(echo "${body}" | awk '/^libhtp-branch/ { print $2 }')
              libhtp_pr=$(echo "${body}" | awk '/^libhtp-pr/ { print $2 }')

              su_repo=$(echo "${body}" | awk '/^suricata-update-repo/ { print $2 }')
              su_branch=$(echo "${body}" | awk '/^suricata-update-branch/ { print $2 }')
              su_pr=$(echo "${body}" | awk '/^suricata-update-pr/ { print $2 }')

              sv_repo=$(echo "${body}" | awk '/^suricata-verify-repo/ { print $2 }')
              sv_branch=$(echo "${body}" | awk '/^suricata-verify-branch/ { print $2 }')
              sv_pr=$(echo "${body}" | awk '/^suricata-verify-pr/ { print $2 }')
          fi
          echo "libhtp_repo=${libhtp_repo:-${DEFAULT_LIBHTP_REPO}}" >> $GITHUB_ENV
          echo "libhtp_branch=${libhtp_branch:-${DEFAULT_LIBHTP_BRANCH}}" >> $GITHUB_ENV
          echo "libhtp_pr=${libhtp_pr:-${DEFAULT_LIBHTP_PR}}" >> $GITHUB_ENV

          echo "su_repo=${su_repo:-${DEFAULT_SU_REPO}}" >> $GITHUB_ENV
          echo "su_branch=${su_branch:-${DEFAULT_SU_BRANCH}}" >> $GITHUB_ENV
          echo "su_pr=${su_pr:-${DEFAULT_SU_PR}}" >> $GITHUB_ENV

          echo "sv_repo=${sv_repo:-${DEFAULT_SV_REPO}}" >> $GITHUB_ENV
          echo "sv_branch=${sv_branch:-${DEFAULT_SV_BRANCH}}" >> $GITHUB_ENV
          echo "sv_pr=${sv_pr:-${DEFAULT_SV_PR}}" >> $GITHUB_ENV
      - name: Fetching libhtp
        run: |
          git clone --depth 1 ${libhtp_repo} -b ${libhtp_branch} libhtp
          if [[ "${libhtp_pr}" != "" ]]; then
              cd libhtp
              git fetch origin pull/${libhtp_pr}/head:prep
              git checkout prep
              cd ..
          fi
          tar zcf libhtp.tar.gz libhtp
      - name: Fetching suricata-update
        run: |
          git clone --depth 1 ${su_repo} -b ${su_branch} suricata-update
          if [[ "${su_pr}" != "" ]]; then
              cd suricata-update
              git fetch origin pull/${su_pr}/head:prep
              git checkout prep
              cd ..
          fi
          tar zcf suricata-update.tar.gz suricata-update
      - name: Fetching suricata-verify
        run: |
          git clone --depth 1 ${sv_repo} -b ${sv_branch} suricata-verify
          if [[ "${sv_pr}" != "" ]]; then
              cd suricata-verify
              git fetch origin pull/${sv_pr}/head:prep
              git checkout prep
              cd ..
          fi
          tar zcf suricata-verify.tar.gz suricata-verify
      - name: Cleaning up
        run: rm -rf libhtp suricata-update suricata-verify
      - name: Uploading prep archive
        uses: actions/upload-artifact@v2
        with:
          name: prep
          path: .

  prepare-cbindgen:
    name: Prepare cbindgen
    runs-on: ubuntu-latest
    steps:
      - name: Cache ~/.cargo
        uses: actions/cache@v1
        with:
          path: ~/.cargo
          key: cbindgen
      - name: Installing Rust
        run: |
          curl https://sh.rustup.rs -sSf | sh -s -- -y
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          rustup target add x86_64-unknown-linux-musl
      - name: Buliding static cbindgen for Linux
        run: |
          cargo install --target x86_64-unknown-linux-musl --debug cbindgen
          cp $HOME/.cargo/bin/cbindgen .
      - name: Uploading prep archive
        uses: actions/upload-artifact@v2
        with:
          name: prep
          path: .

  windows-msys2-mingw64:
    name: Windows MSYS2 MINGW64
    runs-on: windows-latest
    needs: [prepare-deps]
    defaults:
      run:
        shell: msys2 {0}
    steps:
      - uses: actions/checkout@v2
      - uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: git mingw-w64-x86_64-toolchain automake1.16 automake-wrapper autoconf libtool libyaml-devel pcre-devel jansson-devel make mingw-w64-x86_64-libyaml mingw-w64-x86_64-pcre mingw-w64-x86_64-rust mingw-w64-x86_64-jansson unzip p7zip python-setuptools mingw-w64-x86_64-python-yaml mingw-w64-x86_64-jq
      # hack: install our own cbindgen system wide as we can't get the
      # preinstalled one to be picked up by configure
      - name: cbindgen
        run: cargo install --root /usr --force --debug --version 0.14.1 cbindgen
      - uses: actions/checkout@v2
      - uses: actions/download-artifact@v2
        with:
          name: prep
          path: prep
      - run: tar xf prep/libhtp.tar.gz
      - run: tar xf prep/suricata-update.tar.gz
      - name: Npcap DLL
        run: |
          curl -s -O https://nmap.org/npcap/dist/npcap-1.00.exe
          7z -y x -o/npcap-bin npcap-1.00.exe
          # hack: place dlls in cwd
          cp /npcap-bin/*.dll .
      - name: Npcap SDK
        run: |
          curl -s -O https://nmap.org/npcap/dist/npcap-sdk-1.06.zip
          unzip npcap-sdk-1.06.zip -d /npcap
          cp /npcap/Lib/x64/* /usr/lib/
      - run: tar xf prep/suricata-verify.tar.gz
      - name: Build
        run: |
          ./autogen.sh
          CFLAGS="-ggdb -Werror" ./configure --enable-unittests --enable-gccprotect --disable-gccmarch-native --disable-shared --with-libpcap-includes=/npcap/Include --with-libpcap-libraries=/npcap/Lib/x64
          make -j3
      - name: Run
        run: |
          ./src/suricata --build-info
          ./src/suricata -u -l /tmp/
          # need cwd in path due to npcap dlls (see above)
          PATH="$PATH:$(pwd)" python3 ./suricata-verify/run.py
