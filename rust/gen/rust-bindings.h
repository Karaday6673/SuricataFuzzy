/* Copyright (C) 2017 Open Information Security Foundation
*
* You can copy, redistribute or modify this Program under the terms of
* the GNU General Public License version 2 as published by the Free
* Software Foundation.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* version 2 along with this program; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
* 02110-1301, USA.
*/

#ifndef __RUST_BINDINGS_GEN_H_
#define __RUST_BINDINGS_GEN_H_

/* Generated with cbindgen:0.9.0 */

/* DO NOT EDIT This file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "rust.h"

/**
 * The Rust place holder for lua_State.
 */
typedef struct CLuaState CLuaState;

typedef struct RSDNSState RSDNSState;

typedef struct RSDNSTransaction RSDNSTransaction;

/**
 * The Rust place holder for the json_t pointer.
 */
typedef struct rs_json_t rs_json_t;

typedef struct NFSState NFSState;

typedef struct NFSTransaction NFSTransaction;

typedef struct SMBState SMBState;

typedef struct SMBTransaction SMBTransaction;

typedef struct AppLayerGetTxIterTuple {
    void *tx_ptr;
    uint64_t tx_id;
    bool has_next;
} AppLayerGetTxIterTuple;

AppProto ntp_probing_parser(const Flow *_flow,
                            uint8_t _direction,
                            const uint8_t *input,
                            uint32_t input_len,
                            uint8_t *_rdir);

void rs_dhcp_logger_free(void *logger);

rs_json_t *rs_dhcp_logger_log(void *logger, void *tx);

void *rs_dhcp_logger_new(const void *conf);

int32_t rs_dhcp_parse(const Flow *_flow,
                      void *state,
                      void *_pstate,
                      const uint8_t *input,
                      uint32_t input_len,
                      const void *_data,
                      uint8_t _flags);

AppProto rs_dhcp_probing_parser(const Flow *_flow,
                                uint8_t _direction,
                                const uint8_t *input,
                                uint32_t input_len,
                                uint8_t *_rdir);

void rs_dhcp_register_parser(void);

void rs_dhcp_state_free(void *state);

int rs_dhcp_state_get_event_info(const char *event_name,
                                 int *event_id,
                                 AppLayerEventType *event_type);

int8_t rs_dhcp_state_get_event_info_by_id(int event_id,
                                          const char **event_name,
                                          AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_dhcp_state_get_events(void *tx);

void *rs_dhcp_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_dhcp_state_get_tx_count(void *state);

AppLayerGetTxIterTuple rs_dhcp_state_get_tx_iterator(uint8_t _ipproto,
                                                     AppProto _alproto,
                                                     void *state,
                                                     uint64_t min_tx_id,
                                                     uint64_t _max_tx_id,
                                                     uint64_t *istate);

void *rs_dhcp_state_new(void);

int rs_dhcp_state_progress_completion_status(uint8_t _direction);

void rs_dhcp_state_tx_free(void *state, uint64_t tx_id);

int rs_dhcp_tx_get_alstate_progress(void *_tx, uint8_t _direction);

uint32_t rs_dhcp_tx_get_logged(void *_state, void *tx);

void rs_dhcp_tx_set_logged(void *_state, void *tx, uint32_t logged);

rs_json_t *rs_dns_log_json_answer(RSDNSTransaction *tx, uint64_t flags);

rs_json_t *rs_dns_log_json_answer_v1(RSDNSTransaction *tx,
                                     uint16_t i,
                                     uint64_t flags);

rs_json_t *rs_dns_log_json_authority_v1(RSDNSTransaction *tx,
                                        uint16_t i,
                                        uint64_t flags);

rs_json_t *rs_dns_log_json_query(RSDNSTransaction *tx,
                                 uint16_t i,
                                 uint64_t flags);

int rs_dns_lua_get_answer_table(CLuaState *clua, RSDNSTransaction *tx);

int rs_dns_lua_get_authority_table(CLuaState *clua, RSDNSTransaction *tx);

int rs_dns_lua_get_query_table(CLuaState *clua, RSDNSTransaction *tx);

int rs_dns_lua_get_rrname(CLuaState *clua, RSDNSTransaction *tx);

void rs_dns_lua_get_tx_id(CLuaState *clua, RSDNSTransaction *tx);

/**
 * C binding parse a DNS request. Returns 1 on success, -1 on failure.
 */
int8_t rs_dns_parse_request(Flow *_flow,
                            RSDNSState *state,
                            void *_pstate,
                            uint8_t *input,
                            uint32_t input_len,
                            void *_data);

/**
 * C binding parse a DNS request. Returns 1 on success, -1 on failure.
 */
int8_t rs_dns_parse_request_tcp(Flow *_flow,
                                RSDNSState *state,
                                void *_pstate,
                                uint8_t *input,
                                uint32_t input_len,
                                void *_data);

int8_t rs_dns_parse_response(Flow *_flow,
                             RSDNSState *state,
                             void *_pstate,
                             uint8_t *input,
                             uint32_t input_len,
                             void *_data);

int8_t rs_dns_parse_response_tcp(Flow *_flow,
                                 RSDNSState *state,
                                 void *_pstate,
                                 uint8_t *input,
                                 uint32_t input_len,
                                 void *_data);

uint8_t rs_dns_probe(const uint8_t *input, uint32_t len);

uint8_t rs_dns_probe_tcp(const uint8_t *input, uint32_t len);

/**
 * Params:
 * - state: *mut DNSState as void pointer
 */
void rs_dns_state_free(void *state);

AppLayerDecoderEvents *rs_dns_state_get_events(void *tx);

RSDNSTransaction *rs_dns_state_get_tx(RSDNSState *state, uint64_t tx_id);

uint64_t rs_dns_state_get_tx_count(RSDNSState *state);

DetectEngineState *rs_dns_state_get_tx_detect_state(RSDNSTransaction *tx);

/**
 * Returns *mut DNSState
 */
void *rs_dns_state_new(void);

int rs_dns_state_progress_completion_status(uint8_t _direction);

void rs_dns_state_set_tx_detect_state(RSDNSTransaction *tx,
                                      DetectEngineState *de_state);

/**
 * Returns *mut DNSState
 */
void *rs_dns_state_tcp_new(void);

void rs_dns_state_tx_free(RSDNSState *state, uint64_t tx_id);

uint8_t rs_dns_tx_get_alstate_progress(RSDNSTransaction *_tx,
                                       uint8_t _direction);

uint64_t rs_dns_tx_get_detect_flags(RSDNSTransaction *tx, uint8_t dir);

uint32_t rs_dns_tx_get_logged(RSDNSState *_state, RSDNSTransaction *tx);

uint8_t rs_dns_tx_get_query_name(RSDNSTransaction *tx,
                                 uint16_t i,
                                 const uint8_t **buf,
                                 uint32_t *len);

uint8_t rs_dns_tx_get_query_rrtype(RSDNSTransaction *tx,
                                   uint16_t i,
                                   uint16_t *rrtype);

/**
 * Get the DNS response flags for a transaction.
 * extern uint16_t rs_dns_tx_get_response_flags(RSDNSTransaction *);
 */
uint16_t rs_dns_tx_get_response_flags(RSDNSTransaction *tx);

/**
 * Get the DNS transaction ID of a transaction.
 * extern uint16_t rs_dns_tx_get_tx_id(RSDNSTransaction *);
 */
uint16_t rs_dns_tx_get_tx_id(RSDNSTransaction *tx);

void rs_dns_tx_set_detect_flags(RSDNSTransaction *tx,
                                uint8_t dir,
                                uint64_t flags);

void rs_dns_tx_set_logged(RSDNSState *_state,
                          RSDNSTransaction *tx,
                          uint32_t logged);

uint16_t rs_ftp_epsv_response(const uint8_t *input, uint32_t len);

uint16_t rs_ftp_pasv_response(const uint8_t *input, uint32_t len);

rs_json_t *rs_ikev2_log_json_response(IKEV2State *state, IKEV2Transaction *tx);

int32_t rs_ikev2_parse_request(const Flow *_flow,
                               void *state,
                               void *_pstate,
                               const uint8_t *input,
                               uint32_t input_len,
                               const void *_data,
                               uint8_t _flags);

int32_t rs_ikev2_parse_response(const Flow *_flow,
                                void *state,
                                void *pstate,
                                const uint8_t *input,
                                uint32_t input_len,
                                const void *_data,
                                uint8_t _flags);

AppProto rs_ikev2_probing_parser(const Flow *_flow,
                                 uint8_t _direction,
                                 const uint8_t *input,
                                 uint32_t input_len,
                                 uint8_t *_rdir);

/**
 * Params:
 * - state: *mut IKEV2State as void pointer
 */
void rs_ikev2_state_free(void *state);

int rs_ikev2_state_get_event_info(const char *event_name,
                                  int *event_id,
                                  AppLayerEventType *event_type);

int8_t rs_ikev2_state_get_event_info_by_id(int event_id,
                                           const char **event_name,
                                           AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_ikev2_state_get_events(void *tx);

void *rs_ikev2_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_ikev2_state_get_tx_count(void *state);

DetectEngineState *rs_ikev2_state_get_tx_detect_state(void *tx);

/**
 * Returns *mut IKEV2State
 */
void *rs_ikev2_state_new(void);

int rs_ikev2_state_progress_completion_status(uint8_t _direction);

int rs_ikev2_state_set_tx_detect_state(void *tx, DetectEngineState *de_state);

void rs_ikev2_state_tx_free(void *state, uint64_t tx_id);

int rs_ikev2_tx_get_alstate_progress(void *_tx, uint8_t _direction);

uint32_t rs_ikev2_tx_get_logged(void *_state, void *tx);

void rs_ikev2_tx_set_logged(void *_state, void *tx, uint32_t logged);

void rs_init(SuricataContext *context);

rs_json_t *rs_krb5_log_json_response(KRB5State *_state, KRB5Transaction *tx);

int32_t rs_krb5_parse_request(const Flow *_flow,
                              void *state,
                              void *_pstate,
                              const uint8_t *input,
                              uint32_t input_len,
                              const void *_data,
                              uint8_t _flags);

int32_t rs_krb5_parse_request_tcp(const Flow *_flow,
                                  void *state,
                                  void *_pstate,
                                  const uint8_t *input,
                                  uint32_t input_len,
                                  const void *_data,
                                  uint8_t _flags);

int32_t rs_krb5_parse_response(const Flow *_flow,
                               void *state,
                               void *_pstate,
                               const uint8_t *input,
                               uint32_t input_len,
                               const void *_data,
                               uint8_t _flags);

int32_t rs_krb5_parse_response_tcp(const Flow *_flow,
                                   void *state,
                                   void *_pstate,
                                   const uint8_t *input,
                                   uint32_t input_len,
                                   const void *_data,
                                   uint8_t _flags);

AppProto rs_krb5_probing_parser(const Flow *_flow,
                                uint8_t _direction,
                                const uint8_t *input,
                                uint32_t input_len,
                                uint8_t *_rdir);

AppProto rs_krb5_probing_parser_tcp(const Flow *_flow,
                                    uint8_t direction,
                                    const uint8_t *input,
                                    uint32_t input_len,
                                    uint8_t *rdir);

/**
 * Params:
 * - state: *mut KRB5State as void pointer
 */
void rs_krb5_state_free(void *state);

int rs_krb5_state_get_event_info(const char *event_name,
                                 int *event_id,
                                 AppLayerEventType *event_type);

int8_t rs_krb5_state_get_event_info_by_id(int event_id,
                                          const char **event_name,
                                          AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_krb5_state_get_events(void *tx);

void *rs_krb5_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_krb5_state_get_tx_count(void *state);

DetectEngineState *rs_krb5_state_get_tx_detect_state(void *tx);

/**
 * Returns *mut KRB5State
 */
void *rs_krb5_state_new(void);

int rs_krb5_state_progress_completion_status(uint8_t _direction);

int rs_krb5_state_set_tx_detect_state(void *tx, DetectEngineState *de_state);

void rs_krb5_state_tx_free(void *state, uint64_t tx_id);

int rs_krb5_tx_get_alstate_progress(void *_tx, uint8_t _direction);

uint8_t rs_krb5_tx_get_cname(KRB5Transaction *tx,
                             uint16_t i,
                             const uint8_t **buffer,
                             uint32_t *buffer_len);

/**
 * Get error code, if present in transaction
 * Return 0 if error code was filled, else 1
 */
uint32_t rs_krb5_tx_get_errcode(KRB5Transaction *tx, int32_t *ptr);

uint32_t rs_krb5_tx_get_logged(void *_state, void *tx);

void rs_krb5_tx_get_msgtype(KRB5Transaction *tx, uint32_t *ptr);

uint8_t rs_krb5_tx_get_sname(KRB5Transaction *tx,
                             uint16_t i,
                             const uint8_t **buffer,
                             uint32_t *buffer_len);

void rs_krb5_tx_set_logged(void *_state, void *tx, uint32_t logged);

void rs_log_set_level(int32_t level);

FileContainer *rs_nfs_getfiles(uint8_t direction, NFSState *ptr);

void rs_nfs_init(SuricataFileContext *context);

rs_json_t *rs_nfs_log_json_request(NFSState *state, NFSTransaction *tx);

rs_json_t *rs_nfs_log_json_response(NFSState *state, NFSTransaction *tx);

/**
 * C binding parse a NFS TCP request. Returns 1 on success, -1 on failure.
 */
int8_t rs_nfs_parse_request(Flow *_flow,
                            NFSState *state,
                            void *_pstate,
                            uint8_t *input,
                            uint32_t input_len,
                            void *_data);

int8_t rs_nfs_parse_request_tcp_gap(NFSState *state, uint32_t input_len);

/**
 * C binding parse a DNS request. Returns 1 on success, -1 on failure.
 */
int8_t rs_nfs_parse_request_udp(Flow *_flow,
                                NFSState *state,
                                void *_pstate,
                                uint8_t *input,
                                uint32_t input_len,
                                void *_data);

int8_t rs_nfs_parse_response(Flow *_flow,
                             NFSState *state,
                             void *_pstate,
                             uint8_t *input,
                             uint32_t input_len,
                             void *_data);

int8_t rs_nfs_parse_response_tcp_gap(NFSState *state, uint32_t input_len);

int8_t rs_nfs_parse_response_udp(Flow *_flow,
                                 NFSState *state,
                                 void *_pstate,
                                 uint8_t *input,
                                 uint32_t input_len,
                                 void *_data);

int8_t rs_nfs_probe(uint8_t direction, const uint8_t *input, uint32_t len);

/**
 * MIDSTREAM
 */
int8_t rs_nfs_probe_ms(uint8_t direction,
                       const uint8_t *input,
                       uint32_t len,
                       uint8_t *rdir);

/**
 * TOCLIENT probe function
 */
int8_t rs_nfs_probe_udp_tc(const uint8_t *input, uint32_t len);

/**
 * TOSERVER probe function
 */
int8_t rs_nfs_probe_udp_ts(const uint8_t *input, uint32_t len);

void rs_nfs_setfileflags(uint8_t direction, NFSState *ptr, uint16_t flags);

/**
 * Params:
 * - state: *mut NFSState as void pointer
 */
void rs_nfs_state_free(void *state);

int8_t rs_nfs_state_get_event_info(const char *event_name,
                                   int *event_id,
                                   AppLayerEventType *event_type);

int8_t rs_nfs_state_get_event_info_by_id(int event_id,
                                         const char **event_name,
                                         AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_nfs_state_get_events(void *tx);

NFSTransaction *rs_nfs_state_get_tx(NFSState *state, uint64_t tx_id);

uint64_t rs_nfs_state_get_tx_count(NFSState *state);

DetectEngineState *rs_nfs_state_get_tx_detect_state(NFSTransaction *tx);

AppLayerGetTxIterTuple rs_nfs_state_get_tx_iterator(NFSState *state,
                                                    uint64_t min_tx_id,
                                                    uint64_t *istate);

/**
 * Returns *mut NFSState
 */
void *rs_nfs_state_new(void);

int rs_nfs_state_progress_completion_status(uint8_t _direction);

void rs_nfs_state_set_tx_detect_state(NFSTransaction *tx,
                                      DetectEngineState *de_state);

void rs_nfs_state_tx_free(NFSState *state, uint64_t tx_id);

uint8_t rs_nfs_tx_get_alstate_progress(NFSTransaction *tx, uint8_t direction);

uint64_t rs_nfs_tx_get_detect_flags(NFSTransaction *tx, uint8_t direction);

uint32_t rs_nfs_tx_get_logged(NFSState *_state, NFSTransaction *tx);

/**
 * return procedure(s) in the tx. At 0 return the main proc,
 * otherwise get procs from the 'file_additional_procs'.
 * Keep calling until 0 is returned.
 */
uint8_t rs_nfs_tx_get_procedures(NFSTransaction *tx,
                                 uint16_t i,
                                 uint32_t *procedure);

void rs_nfs_tx_get_version(NFSTransaction *tx, uint32_t *version);

uint8_t rs_nfs_tx_logging_is_filtered(NFSState *state, NFSTransaction *tx);

void rs_nfs_tx_set_detect_flags(NFSTransaction *tx,
                                uint8_t direction,
                                uint64_t flags);

void rs_nfs_tx_set_logged(NFSState *_state,
                          NFSTransaction *tx,
                          uint32_t logged);

int32_t rs_ntp_parse_request(const Flow *_flow,
                             void *state,
                             void *_pstate,
                             const uint8_t *input,
                             uint32_t input_len,
                             const void *_data,
                             uint8_t _flags);

int32_t rs_ntp_parse_response(const Flow *_flow,
                              void *state,
                              void *_pstate,
                              const uint8_t *input,
                              uint32_t input_len,
                              const void *_data,
                              uint8_t _flags);

/**
 * Params:
 * - state: *mut NTPState as void pointer
 */
void rs_ntp_state_free(void *state);

int rs_ntp_state_get_event_info(const char *event_name,
                                int *event_id,
                                AppLayerEventType *event_type);

int8_t rs_ntp_state_get_event_info_by_id(int event_id,
                                         const char **event_name,
                                         AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_ntp_state_get_events(void *tx);

void *rs_ntp_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_ntp_state_get_tx_count(void *state);

DetectEngineState *rs_ntp_state_get_tx_detect_state(void *tx);

/**
 * Returns *mut NTPState
 */
void *rs_ntp_state_new(void);

int rs_ntp_state_progress_completion_status(uint8_t _direction);

int rs_ntp_state_set_tx_detect_state(void *tx, DetectEngineState *de_state);

void rs_ntp_state_tx_free(void *state, uint64_t tx_id);

int rs_ntp_tx_get_alstate_progress(void *_tx, uint8_t _direction);

uint32_t rs_ntp_tx_get_logged(NTPState *_state, NTPTransaction *tx);

void rs_ntp_tx_set_logged(NTPState *_state,
                          NTPTransaction *tx,
                          uint32_t logged);

void rs_register_ikev2_parser(void);

void rs_register_krb5_parser(void);

void rs_register_ntp_parser(void);

void rs_register_snmp_parser(void);

rs_json_t *rs_rpc_log_json_response(NFSTransaction *tx);

FileContainer *rs_smb_getfiles(uint8_t direction, SMBState *ptr);

void rs_smb_init(SuricataFileContext *context);

rs_json_t *rs_smb_log_json_request(SMBState *state, SMBTransaction *tx);

rs_json_t *rs_smb_log_json_response(SMBState *state, SMBTransaction *tx);

/**
 * C binding parse a SMB request. Returns 1 on success, -1 on failure.
 */
int8_t rs_smb_parse_request_tcp(Flow *_flow,
                                SMBState *state,
                                void *_pstate,
                                uint8_t *input,
                                uint32_t input_len,
                                void *_data,
                                uint8_t flags);

int8_t rs_smb_parse_request_tcp_gap(SMBState *state, uint32_t input_len);

int8_t rs_smb_parse_response_tcp(Flow *_flow,
                                 SMBState *state,
                                 void *_pstate,
                                 uint8_t *input,
                                 uint32_t input_len,
                                 void *_data,
                                 uint8_t flags);

int8_t rs_smb_parse_response_tcp_gap(SMBState *state, uint32_t input_len);

int8_t rs_smb_probe_tcp(uint8_t direction,
                        const uint8_t *input,
                        uint32_t len,
                        uint8_t *rdir);

void rs_smb_setfileflags(uint8_t direction, SMBState *ptr, uint16_t flags);

/**
 * Params:
 * - state: *mut SMBState as void pointer
 */
void rs_smb_state_free(void *state);

int8_t rs_smb_state_get_event_info(const char *event_name,
                                   int *event_id,
                                   AppLayerEventType *event_type);

int8_t rs_smb_state_get_event_info_by_id(int event_id,
                                         const char **event_name,
                                         AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_smb_state_get_events(void *tx);

SMBTransaction *rs_smb_state_get_tx(SMBState *state, uint64_t tx_id);

uint64_t rs_smb_state_get_tx_count(SMBState *state);

DetectEngineState *rs_smb_state_get_tx_detect_state(SMBTransaction *tx);

AppLayerGetTxIterTuple rs_smb_state_get_tx_iterator(SMBState *state,
                                                    uint64_t min_tx_id,
                                                    uint64_t *istate);

/**
 * Returns *mut SMBState
 */
void *rs_smb_state_new(void);

int rs_smb_state_progress_completion_status(uint8_t _direction);

void rs_smb_state_set_tx_detect_state(SMBTransaction *tx,
                                      DetectEngineState *de_state);

void rs_smb_state_truncate(SMBState *state, uint8_t direction);

void rs_smb_state_tx_free(SMBState *state, uint64_t tx_id);

uint8_t rs_smb_tx_get_alstate_progress(SMBTransaction *tx, uint8_t direction);

uint8_t rs_smb_tx_get_dce_iface(SMBState *state,
                                SMBTransaction *tx,
                                uint8_t *uuid_ptr,
                                uint16_t uuid_len,
                                uint8_t ver_op,
                                uint16_t ver_check);

uint8_t rs_smb_tx_get_dce_opnum(SMBTransaction *tx, uint16_t *opnum);

uint64_t rs_smb_tx_get_detect_flags(SMBTransaction *tx, uint8_t direction);

uint32_t rs_smb_tx_get_logged(SMBState *_state, SMBTransaction *tx);

uint8_t rs_smb_tx_get_named_pipe(SMBTransaction *tx,
                                 const uint8_t **buffer,
                                 uint32_t *buffer_len);

uint8_t rs_smb_tx_get_share(SMBTransaction *tx,
                            const uint8_t **buffer,
                            uint32_t *buffer_len);

uint8_t rs_smb_tx_get_stub_data(SMBTransaction *tx,
                                uint8_t direction,
                                const uint8_t **buffer,
                                uint32_t *buffer_len);

void rs_smb_tx_set_detect_flags(SMBTransaction *tx,
                                uint8_t direction,
                                uint64_t flags);

void rs_smb_tx_set_logged(SMBState *_state, SMBTransaction *tx, uint32_t bits);

AppLayerGetTxIterTuple rs_snmp_get_tx_iterator(uint8_t _ipproto,
                                               AppProto _alproto,
                                               void *alstate,
                                               uint64_t min_tx_id,
                                               uint64_t _max_tx_id,
                                               uint64_t *istate);

rs_json_t *rs_snmp_log_json_response(SNMPState *state, SNMPTransaction *tx);

int32_t rs_snmp_parse_request(const Flow *_flow,
                              void *state,
                              void *_pstate,
                              const uint8_t *input,
                              uint32_t input_len,
                              const void *_data,
                              uint8_t _flags);

int32_t rs_snmp_parse_response(const Flow *_flow,
                               void *state,
                               void *_pstate,
                               const uint8_t *input,
                               uint32_t input_len,
                               const void *_data,
                               uint8_t _flags);

AppProto rs_snmp_probing_parser(const Flow *_flow,
                                uint8_t _direction,
                                const uint8_t *input,
                                uint32_t input_len,
                                uint8_t *_rdir);

/**
 * Params:
 * - state: *mut SNMPState as void pointer
 */
void rs_snmp_state_free(void *state);

int rs_snmp_state_get_event_info(const char *event_name,
                                 int *event_id,
                                 AppLayerEventType *event_type);

int8_t rs_snmp_state_get_event_info_by_id(int event_id,
                                          const char **event_name,
                                          AppLayerEventType *event_type);

AppLayerDecoderEvents *rs_snmp_state_get_events(void *tx);

void *rs_snmp_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_snmp_state_get_tx_count(void *state);

DetectEngineState *rs_snmp_state_get_tx_detect_state(void *tx);

AppLayerGetTxIterTuple rs_snmp_state_get_tx_iterator(SNMPState *state,
                                                     uint64_t min_tx_id,
                                                     uint64_t *istate);

/**
 * Returns *mut SNMPState
 */
void *rs_snmp_state_new(void);

int rs_snmp_state_progress_completion_status(uint8_t _direction);

int rs_snmp_state_set_tx_detect_state(void *tx, DetectEngineState *de_state);

void rs_snmp_state_tx_free(void *state, uint64_t tx_id);

int rs_snmp_tx_get_alstate_progress(void *_tx, uint8_t _direction);

void rs_snmp_tx_get_community(SNMPTransaction *tx,
                              const uint8_t **buf,
                              uint32_t *len);

uint32_t rs_snmp_tx_get_logged(void *_state, void *tx);

void rs_snmp_tx_get_pdu_type(SNMPTransaction *tx, uint32_t *pdu_type);

void rs_snmp_tx_get_version(SNMPTransaction *tx, uint32_t *version);

void rs_snmp_tx_set_logged(void *_state, void *tx, uint32_t logged);

/**
 * Get the request buffer for a transaction from C.
 * No required for parsing, but an example function for retrieving a
 * pointer to the request buffer from C for detection.
 */
uint8_t rs_template_get_request_buffer(void *tx,
                                       const uint8_t **buf,
                                       uint32_t *len);

/**
 * Get the response buffer for a transaction from C.
 */
uint8_t rs_template_get_response_buffer(void *tx,
                                        const uint8_t **buf,
                                        uint32_t *len);

rs_json_t *rs_template_logger_log(void *tx);

int32_t rs_template_parse_request(const Flow *_flow,
                                  void *state,
                                  void *pstate,
                                  const uint8_t *input,
                                  uint32_t input_len,
                                  const void *_data,
                                  uint8_t _flags);

int32_t rs_template_parse_response(const Flow *_flow,
                                   void *state,
                                   void *pstate,
                                   const uint8_t *input,
                                   uint32_t input_len,
                                   const void *_data,
                                   uint8_t _flags);

/**
 * C entry point for a probing parser.
 */
AppProto rs_template_probing_parser(const Flow *_flow,
                                    uint8_t _direction,
                                    const uint8_t *input,
                                    uint32_t input_len,
                                    uint8_t *_rdir);

void rs_template_register_parser(void);

void rs_template_state_free(void *state);

int rs_template_state_get_event_info(const char *_event_name,
                                     int *_event_id,
                                     AppLayerEventType *_event_type);

int8_t rs_template_state_get_event_info_by_id(int _event_id,
                                              const char **_event_name,
                                              AppLayerEventType *_event_type);

AppLayerDecoderEvents *rs_template_state_get_events(void *tx);

void *rs_template_state_get_tx(void *state, uint64_t tx_id);

uint64_t rs_template_state_get_tx_count(void *state);

AppLayerGetTxIterTuple rs_template_state_get_tx_iterator(uint8_t _ipproto,
                                                         AppProto _alproto,
                                                         void *state,
                                                         uint64_t min_tx_id,
                                                         uint64_t _max_tx_id,
                                                         uint64_t *istate);

void *rs_template_state_new(void);

int rs_template_state_progress_completion_status(uint8_t _direction);

void rs_template_state_tx_free(void *state, uint64_t tx_id);

int rs_template_tx_get_alstate_progress(void *tx, uint8_t _direction);

uint32_t rs_template_tx_get_logged(void *_state, void *tx);

void rs_template_tx_set_logged(void *_state, void *tx, uint32_t logged);

void *rs_tftp_get_tx(TFTPState *state, uint64_t tx_id);

uint64_t rs_tftp_get_tx_cnt(TFTPState *state);

uint32_t rs_tftp_get_tx_logged(TFTPState *_state, TFTPTransaction *tx);

rs_json_t *rs_tftp_log_json_request(TFTPTransaction *tx);

int64_t rs_tftp_request(TFTPState *state, const uint8_t *input, uint32_t len);

void rs_tftp_set_tx_logged(TFTPState *_state,
                           TFTPTransaction *tx,
                           uint32_t logged);

void *rs_tftp_state_alloc(void);

void rs_tftp_state_free(void *state);

void rs_tftp_state_tx_free(TFTPState *state, uint64_t tx_id);

#endif /* __RUST_BINDINGS_GEN_H_ */
